import numpy as npimport matplotlib.pyplot as pltdef f(t, y):    # Define the ODE y' = f(t, y)    return t - ydef rk4_step(f, t, y, h):    # Runge-Kutta 4th Order Method    k1 = h * f(t, y)    k2 = h * f(t + h/2, y + k1/2)    k3 = h * f(t + h/2, y + k2/2)    k4 = h * f(t + h, y + k3)    y_next = y + (k1 + 2*k2 + 2*k3 + k4) / 6    return y_nextdef adams_bashforth_moulton_adaptive(f, t_values, y0, tol):    # Calculate the step size from t_values    h = t_values[1] - t_values[0]        # Adaptive step size parameters    t_values_list = [t_values[0]]    y_values_list = [y0]        # Initial conditions for the first few steps using RK4    t = t_values[0]    y = y0        # Compute initial points using RK4    for i in range(3):        y_next = rk4_step(f, t, y, h)        t += h        t_values_list.append(t)        y_values_list.append(y_next)        y = y_next        # Adams-Bashforth-Moulton method with adaptive step size    for i in range(3, len(t_values) - 1):        # Adams-Bashforth predictor        y_pred = y_values_list[-1] + h/24 * (55*f(t_values_list[-1], y_values_list[-1]) - 59*f(t_values_list[-2], y_values_list[-2]) + 37*f(t_values_list[-3], y_values_list[-3]) - 9*f(t_values_list[-4], y_values_list[-4]))                # Adams-Moulton corrector        t_next = t_values[i + 1]        y_correct = y_values_list[-1] + h/24 * (9*f(t_next, y_pred) + 19*f(t_values_list[-1], y_values_list[-1]) - 5*f(t_values_list[-2], y_values_list[-2]) + f(t_values_list[-3], y_values_list[-3]))                # Error estimation        error = np.abs(y_correct - y_pred)                # Step size adjustment        if error > tol:            # Reduce step size            h *= 0.9 * (tol / error) ** 0.25            t_values_list = t_values_list[:-1]  # Remove last time step            y_values_list = y_values_list[:-1]  # Remove last solution        else:            t_values_list.append(t_next)            y_values_list.append(y_correct)            # Update history for the next iteration            t_values_list[-4:] = [t_values_list[-3], t_values_list[-2], t_values_list[-1], t_next]            y_values_list[-4:] = [y_values_list[-3], y_values_list[-2], y_values_list[-1], y_correct]            h *= 1.5  # Increase step size for efficiency        return np.array(t_values_list), np.array(y_values_list)# Example usaget_values = np.linspace(0, 10, 101)  # Array of time stepsy0 = 1tol = 1e-6# Solve the ODEt_values_list, y_values_list = adams_bashforth_moulton_adaptive(f, t_values, y0, tol)# Plot the solutionplt.plot(t_values_list, y_values_list, label='Adams-Bashforth-Moulton Adaptive')plt.xlabel('t')plt.ylabel('y')plt.legend()plt.title("Adaptive Adams-Bashforth-Moulton Method")plt.show()